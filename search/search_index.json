{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"headscale","text":"<p><code>headscale</code> is an open source, self-hosted implementation of the Tailscale control server.</p> <p>This page contains the documentation for the latest version of headscale. Please also check our FAQ.</p> <p>Join our Discord server for a chat and community support.</p>"},{"location":"#design-goal","title":"Design goal","text":"<p>Headscale aims to implement a self-hosted, open source alternative to the Tailscale control server. Headscale's goal is to provide self-hosters and hobbyists with an open-source server they can use for their projects and labs. It implements a narrower scope, a single Tailnet, suitable for a personal use, or a small open-source organisation.</p>"},{"location":"#supporting-headscale","title":"Supporting headscale","text":"<p>If you like <code>headscale</code> and find it useful, there is a sponsorship and donation buttons available in the repo.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Headscale is \"Open Source, acknowledged contribution\", this means that any contribution will have to be discussed with the Maintainers before being submitted.</p> <p>This model has been chosen to reduce the risk of burnout by limiting the maintenance overhead of reviewing and validating third-party code.</p> <p>Headscale is open to code contributions for bug fixes without discussion.</p> <p>If you find mistakes in the documentation, please submit a fix to the documentation.</p>"},{"location":"#about","title":"About","text":"<p><code>headscale</code> is maintained by Kristoffer Dalby and Juan Font.</p>"},{"location":"acls/","title":"ACLs","text":"<p>Headscale implements the same policy ACLs as Tailscale.com, adapted to the self-hosted environment.</p> <p>For instance, instead of referring to users when defining groups you must use users (which are the equivalent to user/logins in Tailscale.com).</p> <p>Please check https://tailscale.com/kb/1018/acls/, and <code>./tests/acls/</code> in this repo for working examples.</p> <p>When using ACL's the User borders are no longer applied. All machines whichever the User have the ability to communicate with other hosts as long as the ACL's permits this exchange.</p>"},{"location":"acls/#acls-use-case-example","title":"ACLs use case example","text":"<p>Let's build an example use case for a small business (It may be the place where ACL's are the most useful).</p> <p>We have a small company with a boss, an admin, two developers and an intern.</p> <p>The boss should have access to all servers but not to the user's hosts. Admin should also have access to all hosts except that their permissions should be limited to maintaining the hosts (for example purposes). The developers can do anything they want on dev hosts but only watch on productions hosts. Intern can only interact with the development servers.</p> <p>There's an additional server that acts as a router, connecting the VPN users to an internal network <code>10.20.0.0/16</code>. Developers must have access to those internal resources.</p> <p>Each user have at least a device connected to the network and we have some servers.</p> <ul> <li>database.prod</li> <li>database.dev</li> <li>app-server1.prod</li> <li>app-server1.dev</li> <li>billing.internal</li> <li>router.internal</li> </ul> <p></p>"},{"location":"acls/#acl-setup","title":"ACL setup","text":"<p>Note: Users will be created automatically when users authenticate with the Headscale server.</p> <p>ACLs could be written either on huJSON or YAML. Check the test ACLs for further information.</p> <p>When registering the servers we will need to add the flag <code>--advertise-tags=tag:&lt;tag1&gt;,tag:&lt;tag2&gt;</code>, and the user that is registering the server should be allowed to do it. Since anyone can add tags to a server they can register, the check of the tags is done on headscale server and only valid tags are applied. A tag is valid if the user that is registering it is allowed to do it.</p> <p>To use ACLs in headscale, you must edit your config.yaml file. In there you will find a <code>acl_policy_path: \"\"</code> parameter. This will need to point to your ACL file. More info on how these policies are written can be found here.</p> <p>Here are the ACL's to implement the same permissions as above:</p> <pre><code>{\n// groups are collections of users having a common scope. A user can be in multiple groups\n// groups cannot be composed of groups\n\"groups\": {\n\"group:boss\": [\"boss\"],\n\"group:dev\": [\"dev1\", \"dev2\"],\n\"group:admin\": [\"admin1\"],\n\"group:intern\": [\"intern1\"]\n},\n// tagOwners in tailscale is an association between a TAG and the people allowed to set this TAG on a server.\n// This is documented [here](https://tailscale.com/kb/1068/acl-tags#defining-a-tag)\n// and explained [here](https://tailscale.com/blog/rbac-like-it-was-meant-to-be/)\n\"tagOwners\": {\n// the administrators can add servers in production\n\"tag:prod-databases\": [\"group:admin\"],\n\"tag:prod-app-servers\": [\"group:admin\"],\n// the boss can tag any server as internal\n\"tag:internal\": [\"group:boss\"],\n// dev can add servers for dev purposes as well as admins\n\"tag:dev-databases\": [\"group:admin\", \"group:dev\"],\n\"tag:dev-app-servers\": [\"group:admin\", \"group:dev\"]\n// interns cannot add servers\n},\n// hosts should be defined using its IP addresses and a subnet mask.\n// to define a single host, use a /32 mask. You cannot use DNS entries here,\n// as they're prone to be hijacked by replacing their IP addresses.\n// see https://github.com/tailscale/tailscale/issues/3800 for more information.\n\"Hosts\": {\n\"postgresql.internal\": \"10.20.0.2/32\",\n\"webservers.internal\": \"10.20.10.1/29\"\n},\n\"acls\": [\n// boss have access to all servers\n{\n\"action\": \"accept\",\n\"src\": [\"group:boss\"],\n\"dst\": [\n\"tag:prod-databases:*\",\n\"tag:prod-app-servers:*\",\n\"tag:internal:*\",\n\"tag:dev-databases:*\",\n\"tag:dev-app-servers:*\"\n]\n},\n// admin have only access to administrative ports of the servers, in tcp/22\n{\n\"action\": \"accept\",\n\"src\": [\"group:admin\"],\n\"proto\": \"tcp\",\n\"dst\": [\n\"tag:prod-databases:22\",\n\"tag:prod-app-servers:22\",\n\"tag:internal:22\",\n\"tag:dev-databases:22\",\n\"tag:dev-app-servers:22\"\n]\n},\n// we also allow admin to ping the servers\n{\n\"action\": \"accept\",\n\"src\": [\"group:admin\"],\n\"proto\": \"icmp\",\n\"dst\": [\n\"tag:prod-databases:*\",\n\"tag:prod-app-servers:*\",\n\"tag:internal:*\",\n\"tag:dev-databases:*\",\n\"tag:dev-app-servers:*\"\n]\n},\n// developers have access to databases servers and application servers on all ports\n// they can only view the applications servers in prod and have no access to databases servers in production\n{\n\"action\": \"accept\",\n\"src\": [\"group:dev\"],\n\"dst\": [\n\"tag:dev-databases:*\",\n\"tag:dev-app-servers:*\",\n\"tag:prod-app-servers:80,443\"\n]\n},\n// developers have access to the internal network through the router.\n// the internal network is composed of HTTPS endpoints and Postgresql\n// database servers. There's an additional rule to allow traffic to be\n// forwarded to the internal subnet, 10.20.0.0/16. See this issue\n// https://github.com/juanfont/headscale/issues/502\n{\n\"action\": \"accept\",\n\"src\": [\"group:dev\"],\n\"dst\": [\"10.20.0.0/16:443,5432\", \"router.internal:0\"]\n},\n// servers should be able to talk to database in tcp/5432. Database should not be able to initiate connections to\n// applications servers\n{\n\"action\": \"accept\",\n\"src\": [\"tag:dev-app-servers\"],\n\"proto\": \"tcp\",\n\"dst\": [\"tag:dev-databases:5432\"]\n},\n{\n\"action\": \"accept\",\n\"src\": [\"tag:prod-app-servers\"],\n\"dst\": [\"tag:prod-databases:5432\"]\n},\n// interns have access to dev-app-servers only in reading mode\n{\n\"action\": \"accept\",\n\"src\": [\"group:intern\"],\n\"dst\": [\"tag:dev-app-servers:80,443\"]\n},\n// We still have to allow internal users communications since nothing guarantees that each user have\n// their own users.\n{ \"action\": \"accept\", \"src\": [\"boss\"], \"dst\": [\"boss:*\"] },\n{ \"action\": \"accept\", \"src\": [\"dev1\"], \"dst\": [\"dev1:*\"] },\n{ \"action\": \"accept\", \"src\": [\"dev2\"], \"dst\": [\"dev2:*\"] },\n{ \"action\": \"accept\", \"src\": [\"admin1\"], \"dst\": [\"admin1:*\"] },\n{ \"action\": \"accept\", \"src\": [\"intern1\"], \"dst\": [\"intern1:*\"] }\n]\n}\n</code></pre>"},{"location":"android-client/","title":"Connecting an Android client","text":""},{"location":"android-client/#goal","title":"Goal","text":"<p>This documentation has the goal of showing how a user can use the official Android Tailscale client with <code>headscale</code>.</p>"},{"location":"android-client/#installation","title":"Installation","text":"<p>Install the official Tailscale Android client from the Google Play Store or F-Droid.</p> <p>Ensure that the installed version is at least 1.30.0, as that is the first release to support custom URLs.</p>"},{"location":"android-client/#configuring-the-headscale-url","title":"Configuring the headscale URL","text":"<p>After opening the app, the kebab menu icon (three dots) on the top bar on the right must be repeatedly opened and closed until the Change server option appears in the menu. This is where you can enter your headscale URL.</p> <p>A screen recording of this process can be seen in the <code>tailscale-android</code> PR which implemented this functionality: https://github.com/tailscale/tailscale-android/pull/55</p> <p>After saving and restarting the app, selecting the regular Sign in option (non-SSO) should open up the headscale authentication page.</p>"},{"location":"dns-records/","title":"Setting custom DNS records","text":"<p>Community documentation</p> <p>This page is not actively maintained by the headscale authors and is written by community members. It is not verified by <code>headscale</code> developers.</p> <p>It might be outdated and it might miss necessary steps.</p>"},{"location":"dns-records/#goal","title":"Goal","text":"<p>This documentation has the goal of showing how a user can set custom DNS records with <code>headscale</code>s magic dns. An example use case is to serve apps on the same host via a reverse proxy like NGINX, in this case a Prometheus monitoring stack. This allows to nicely access the service with \"http://grafana.myvpn.example.com\" instead of the hostname and portnum combination \"http://hostname-in-magic-dns.myvpn.example.com:3000\".</p>"},{"location":"dns-records/#setup","title":"Setup","text":""},{"location":"dns-records/#1-change-the-configuration","title":"1. Change the configuration","text":"<ol> <li>Change the <code>config.yaml</code> to contain the desired records like so:</li> </ol> <pre><code>dns_config:\n...\nextra_records:\n- name: \"prometheus.myvpn.example.com\"\ntype: \"A\"\nvalue: \"100.64.0.3\"\n- name: \"grafana.myvpn.example.com\"\ntype: \"A\"\nvalue: \"100.64.0.3\"\n...\n</code></pre> <ol> <li>Restart your headscale instance.</li> </ol> <p>Beware of the limitations listed later on!</p>"},{"location":"dns-records/#2-verify-that-the-records-are-set","title":"2. Verify that the records are set","text":"<p>You can use a DNS querying tool of your choice on one of your hosts to verify that your newly set records are actually available in MagicDNS, here we used <code>dig</code>:</p> <pre><code>$ dig grafana.myvpn.example.com\n\n; &lt;&lt;&gt;&gt; DiG 9.18.10 &lt;&lt;&gt;&gt; grafana.myvpn.example.com\n;; global options: +cmd\n;; Got answer:\n;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 44054\n;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1\n\n;; OPT PSEUDOSECTION:\n; EDNS: version: 0, flags:; udp: 65494\n;; QUESTION SECTION:\n;grafana.myvpn.example.com.         IN      A\n\n;; ANSWER SECTION:\ngrafana.myvpn.example.com.  593     IN      A       100.64.0.3\n\n;; Query time: 0 msec\n;; SERVER: 127.0.0.53#53(127.0.0.53) (UDP)\n;; WHEN: Sat Dec 31 11:46:55 CET 2022\n;; MSG SIZE  rcvd: 66\n</code></pre>"},{"location":"dns-records/#3-optional-setup-the-reverse-proxy","title":"3. Optional: Setup the reverse proxy","text":"<p>The motivating example here was to be able to access internal monitoring services on the same host without specifying a port:</p> <pre><code>server {\n    listen 80;\n    listen [::]:80;\n\n    server_name grafana.myvpn.example.com;\n\n    location / {\n        proxy_pass http://localhost:3000;\n        proxy_set_header Host $http_host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header X-Forwarded-Proto $scheme;\n    }\n\n}\n</code></pre>"},{"location":"dns-records/#limitations","title":"Limitations","text":"<p>Not all types of records are supported, especially no CNAME records.</p>"},{"location":"exit-node/","title":"Exit Nodes","text":""},{"location":"exit-node/#on-the-node","title":"On the node","text":"<p>Register the node and make it advertise itself as an exit node:</p> <pre><code>$ sudo tailscale up --login-server https://my-server.com --advertise-exit-node\n</code></pre> <p>If the node is already registered, it can advertise exit capabilities like this:</p> <pre><code>$ sudo tailscale set --advertise-exit-node\n</code></pre> <p>To use a node as an exit node, IP forwarding must be enabled on the node. Check the official Tailscale documentation for how to enable IP fowarding.</p>"},{"location":"exit-node/#on-the-control-server","title":"On the control server","text":"<pre><code>$ # list nodes\n$ headscale routes list\nID | Machine | Prefix    | Advertised | Enabled | Primary\n1  |         | 0.0.0.0/0 | false      | false   | -\n2  |         | ::/0      | false      | false   | -\n3  | phobos  | 0.0.0.0/0 | true       | false   | -\n4  | phobos  | ::/0      | true       | false   | -\n$ # enable routes for phobos\n$ headscale routes enable -r 3\n$ headscale routes enable -r 4\n$ # Check node list again. The routes are now enabled.\n$ headscale routes list\nID | Machine | Prefix    | Advertised | Enabled | Primary\n1  |         | 0.0.0.0/0 | false      | false   | -\n2  |         | ::/0      | false      | false   | -\n3  | phobos  | 0.0.0.0/0 | true       | true    | -\n4  | phobos  | ::/0      | true       | true    | -\n</code></pre>"},{"location":"exit-node/#on-the-client","title":"On the client","text":"<p>The exit node can now be used with:</p> <pre><code>$ sudo tailscale set --exit-node phobos\n</code></pre> <p>Check the official Tailscale documentation for how to do it on your device.</p>"},{"location":"faq/","title":"Frequently Asked Questions","text":""},{"location":"faq/#what-is-the-design-goal-of-headscale","title":"What is the design goal of headscale?","text":"<p><code>headscale</code> aims to implement a self-hosted, open source alternative to the Tailscale control server. <code>headscale</code>'s goal is to provide self-hosters and hobbyists with an open-source server they can use for their projects and labs. It implements a narrow scope, a single Tailnet, suitable for a personal use, or a small open-source organisation.</p>"},{"location":"faq/#how-can-i-contribute","title":"How can I contribute?","text":"<p>Headscale is \"Open Source, acknowledged contribution\", this means that any contribution will have to be discussed with the Maintainers before being submitted.</p> <p>Headscale is open to code contributions for bug fixes without discussion.</p> <p>If you find mistakes in the documentation, please also submit a fix to the documentation.</p>"},{"location":"faq/#why-is-acknowledged-contribution-the-chosen-model","title":"Why is 'acknowledged contribution' the chosen model?","text":"<p>Both maintainers have full-time jobs and families, and we want to avoid burnout. We also want to avoid frustration from contributors when their PRs are not accepted.</p> <p>We are more than happy to exchange emails, or to have dedicated calls before a PR is submitted.</p>"},{"location":"faq/#whenwhy-is-feature-x-going-to-be-implemented","title":"When/Why is Feature X going to be implemented?","text":"<p>We don't know. We might be working on it. If you want to help, please send us a PR.</p> <p>Please be aware that there are a number of reasons why we might not accept specific contributions:</p> <ul> <li>It is not possible to implement the feature in a way that makes sense in a self-hosted environment.</li> <li>Given that we are reverse-engineering Tailscale to satify our own curiosity, we might be interested in implementing the feature ourselves.</li> <li>You are not sending unit and integration tests with it.</li> </ul>"},{"location":"faq/#do-you-support-y-method-of-deploying-headscale","title":"Do you support Y method of deploying Headscale?","text":"<p>We currently support deploying <code>headscale</code> using our binaries and the DEB packages. Both can be found in the GitHub releases page.</p> <p>In addition to that, there are semi-official RPM packages by the Fedora infra team https://copr.fedorainfracloud.org/coprs/jonathanspw/headscale/</p> <p>For convenience, we also build Docker images with <code>headscale</code>. But please be aware that we don't officially support deploying <code>headscale</code> using Docker. We have a Discord channel where you can ask for Docker-specific help to the community.</p>"},{"location":"faq/#why-is-my-reverse-proxy-not-working-with-headscale","title":"Why is my reverse proxy not working with Headscale?","text":"<p>We don't know. We don't use reverse proxies with <code>headscale</code> ourselves, so we don't have any experience with them. We have community documentation on how to configure various reverse proxies, and a dedicated Discord channel where you can ask for help to the community.</p>"},{"location":"glossary/","title":"Glossary","text":"Term Description Machine A machine is a single entity connected to <code>headscale</code>, typically an installation of Tailscale. Also known as Node Namespace A namespace was a logical grouping of machines \"owned\" by the same entity, in Tailscale, this is typically a User (This is now called user)"},{"location":"iOS-client/","title":"Connecting an iOS client","text":""},{"location":"iOS-client/#goal","title":"Goal","text":"<p>This documentation has the goal of showing how a user can use the official iOS Tailscale client with <code>headscale</code>.</p>"},{"location":"iOS-client/#installation","title":"Installation","text":"<p>Install the official Tailscale iOS client from the App Store.</p> <p>Ensure that the installed version is at least 1.38.1, as that is the first release to support alternate control servers.</p>"},{"location":"iOS-client/#configuring-the-headscale-url","title":"Configuring the headscale URL","text":"<p>Apple devices</p> <p>An endpoint with information on how to connect your Apple devices (currently macOS only) is available at <code>/apple</code> on your running instance.</p> <p>Ensure that the tailscale app is logged out before proceeding.</p> <p>Go to iOS settings, scroll down past game center and tv provider to the tailscale app and select it. The headscale URL can be entered into the \"ALTERNATE COORDINATION SERVER URL\" box.</p> <p>Note</p> <p>If the app was previously logged into tailscale, toggle on the Reset Keychain switch.</p> <p>Restart the app by closing it from the iOS app switcher, open the app and select the regular Sign in option (non-SSO), and it should open up to the headscale authentication page.</p> <p>Enter your credentials and log in. Headscale should now be working on your iOS device.</p>"},{"location":"oidc/","title":"Configuring Headscale to use OIDC authentication","text":"<p>In order to authenticate users through a centralized solution one must enable the OIDC integration.</p> <p>Known limitations:</p> <ul> <li>No dynamic ACL support</li> <li>OIDC groups cannot be used in ACLs</li> </ul>"},{"location":"oidc/#basic-configuration","title":"Basic configuration","text":"<p>In your <code>config.yaml</code>, customize this to your liking:</p> <pre><code>oidc:\n# Block further startup until the OIDC provider is healthy and available\nonly_start_if_oidc_is_available: true\n# Specified by your OIDC provider\nissuer: \"https://your-oidc.issuer.com/path\"\n# Specified/generated by your OIDC provider\nclient_id: \"your-oidc-client-id\"\nclient_secret: \"your-oidc-client-secret\"\n# alternatively, set `client_secret_path` to read the secret from the file.\n# It resolves environment variables, making integration to systemd's\n# `LoadCredential` straightforward:\n#client_secret_path: \"${CREDENTIALS_DIRECTORY}/oidc_client_secret\"\n# Customize the scopes used in the OIDC flow, defaults to \"openid\", \"profile\" and \"email\" and add custom query\n# parameters to the Authorize Endpoint request. Scopes default to \"openid\", \"profile\" and \"email\".\nscope: [\"openid\", \"profile\", \"email\", \"custom\"]\n# Optional: Passed on to the browser login request \u2013 used to tweak behaviour for the OIDC provider\nextra_params:\ndomain_hint: example.com\n# Optional: List allowed principal domains and/or users. If an authenticated user's domain is not in this list,\n# the authentication request will be rejected.\nallowed_domains:\n- example.com\n# Optional. Note that groups from Keycloak have a leading '/'.\nallowed_groups:\n- /headscale\n# Optional.\nallowed_users:\n- alice@example.com\n# If `strip_email_domain` is set to `true`, the domain part of the username email address will be removed.\n# This will transform `first-name.last-name@example.com` to the user `first-name.last-name`\n# If `strip_email_domain` is set to `false` the domain part will NOT be removed resulting to the following\n# user: `first-name.last-name.example.com`\nstrip_email_domain: true\n</code></pre>"},{"location":"oidc/#azure-ad-example","title":"Azure AD example","text":"<p>In order to integrate Headscale with Azure Active Directory, we'll need to provision an App Registration with the correct scopes and redirect URI. Here with Terraform:</p> <pre><code>resource \"azuread_application\" \"headscale\" {\ndisplay_name = \"Headscale\"\nsign_in_audience = \"AzureADMyOrg\"\nfallback_public_client_enabled = false\nrequired_resource_access {\n    // Microsoft Graph\nresource_app_id = \"00000003-0000-0000-c000-000000000000\"\nresource_access {\n      // scope: profile\nid   = \"14dad69e-099b-42c9-810b-d002981feec1\"\ntype = \"Scope\"\n}\nresource_access {\n      // scope: openid\nid   = \"37f7f235-527c-4136-accd-4a02d197296e\"\ntype = \"Scope\"\n}\nresource_access {\n      // scope: email\nid   = \"64a6cdd6-aab1-4aaf-94b8-3cc8405e90d0\"\ntype = \"Scope\"\n}\n}\nweb {\n    # Points at your running Headscale instance\nredirect_uris = [\"https://headscale.example.com/oidc/callback\"]\nimplicit_grant {\naccess_token_issuance_enabled = false\nid_token_issuance_enabled = true\n}\n}\ngroup_membership_claims = [\"SecurityGroup\"]\noptional_claims {\n    # Expose group memberships\nid_token {\nname = \"groups\"\n}\n}\n}\nresource \"azuread_application_password\" \"headscale-application-secret\" {\ndisplay_name          = \"Headscale Server\"\napplication_object_id = azuread_application.headscale.object_id\n}\nresource \"azuread_service_principal\" \"headscale\" {\napplication_id = azuread_application.headscale.application_id\n}\nresource \"azuread_service_principal_password\" \"headscale\" {\nservice_principal_id = azuread_service_principal.headscale.id\nend_date_relative    = \"44640h\"\n}\noutput \"headscale_client_id\" {\nvalue = azuread_application.headscale.application_id\n}\noutput \"headscale_client_secret\" {\nvalue = azuread_application_password.headscale-application-secret.value\n}\n</code></pre> <p>And in your Headscale <code>config.yaml</code>:</p> <pre><code>oidc:\nissuer: \"https://login.microsoftonline.com/&lt;tenant-UUID&gt;/v2.0\"\nclient_id: \"&lt;client-id-from-terraform&gt;\"\nclient_secret: \"&lt;client-secret-from-terraform&gt;\"\n# Optional: add \"groups\"\nscope: [\"openid\", \"profile\", \"email\"]\nextra_params:\n# Use your own domain, associated with Azure AD\ndomain_hint: example.com\n# Optional: Force the Azure AD account picker\nprompt: select_account\n</code></pre>"},{"location":"oidc/#google-oauth-example","title":"Google OAuth Example","text":"<p>In order to integrate Headscale with Google, you'll need to have a Google Cloud Console account.</p> <p>Google OAuth has a verification process if you need to have users authenticate who are outside of your domain. If you only need to authenticate users from your domain name (ie <code>@example.com</code>), you don't need to go through the verification process.</p> <p>However if you don't have a domain, or need to add users outside of your domain, you can manually add emails via Google Console.</p>"},{"location":"oidc/#steps","title":"Steps","text":"<ol> <li>Go to Google Console and login or create an account if you don't have one.</li> <li>Create a project (if you don't already have one).</li> <li>On the left hand menu, go to <code>APIs and services</code> -&gt; <code>Credentials</code></li> <li>Click <code>Create Credentials</code> -&gt; <code>OAuth client ID</code></li> <li>Under <code>Application Type</code>, choose <code>Web Application</code></li> <li>For <code>Name</code>, enter whatever you like</li> <li>Under <code>Authorised redirect URIs</code>, use <code>https://example.com/oidc/callback</code>, replacing example.com with your Headscale URL.</li> <li>Click <code>Save</code> at the bottom of the form</li> <li>Take note of the <code>Client ID</code> and <code>Client secret</code>, you can also download it for reference if you need it.</li> <li>Edit your headscale config, under <code>oidc</code>, filling in your <code>client_id</code> and <code>client_secret</code>:</li> </ol> <pre><code>oidc:\nissuer: \"https://accounts.google.com\"\nclient_id: \"\"\nclient_secret: \"\"\nscope: [\"openid\", \"profile\", \"email\"]\n</code></pre> <p>You can also use <code>allowed_domains</code> and <code>allowed_users</code> to restrict the users who can authenticate.</p>"},{"location":"remote-cli/","title":"Controlling <code>headscale</code> with remote CLI","text":""},{"location":"remote-cli/#prerequisit","title":"Prerequisit","text":"<ul> <li>A workstation to run <code>headscale</code> (could be Linux, macOS, other supported platforms)</li> <li>A <code>headscale</code> server (version <code>0.13.0</code> or newer)</li> <li>Access to create API keys (local access to the <code>headscale</code> server)</li> <li><code>headscale</code> must be served over TLS/HTTPS</li> <li>Remote access does not support unencrypted traffic.</li> <li>Port <code>50443</code> must be open in the firewall (or port overriden by <code>grpc_listen_addr</code> option)</li> </ul>"},{"location":"remote-cli/#goal","title":"Goal","text":"<p>This documentation has the goal of showing a user how-to set control a <code>headscale</code> instance from a remote machine with the <code>headscale</code> command line binary.</p>"},{"location":"remote-cli/#create-an-api-key","title":"Create an API key","text":"<p>We need to create an API key to authenticate our remote <code>headscale</code> when using it from our workstation.</p> <p>To create a API key, log into your <code>headscale</code> server and generate a key:</p> <pre><code>headscale apikeys create --expiration 90d\n</code></pre> <p>Copy the output of the command and save it for later. Please note that you can not retrieve a key again, if the key is lost, expire the old one, and create a new key.</p> <p>To list the keys currently assosicated with the server:</p> <pre><code>headscale apikeys list\n</code></pre> <p>and to expire a key:</p> <pre><code>headscale apikeys expire --prefix \"&lt;PREFIX&gt;\"\n</code></pre>"},{"location":"remote-cli/#download-and-configure-headscale","title":"Download and configure <code>headscale</code>","text":"<ol> <li> <p>Download the latest <code>headscale</code> binary from GitHub's release page:</p> </li> <li> <p>Put the binary somewhere in your <code>PATH</code>, e.g. <code>/usr/local/bin/headscale</code></p> </li> <li> <p>Make <code>headscale</code> executable:</p> </li> </ol> <pre><code>chmod +x /usr/local/bin/headscale\n</code></pre> <ol> <li>Configure the CLI through Environment Variables</li> </ol> <pre><code>export HEADSCALE_CLI_ADDRESS=\"&lt;HEADSCALE ADDRESS&gt;:&lt;PORT&gt;\"\nexport HEADSCALE_CLI_API_KEY=\"&lt;API KEY FROM PREVIOUS STAGE&gt;\"\n</code></pre> <p>for example:</p> <pre><code>export HEADSCALE_CLI_ADDRESS=\"headscale.example.com:50443\"\nexport HEADSCALE_CLI_API_KEY=\"abcde12345\"\n</code></pre> <p>This will tell the <code>headscale</code> binary to connect to a remote instance, instead of looking for a local instance (which is what it does on the server).</p> <p>The API key is needed to make sure that your are allowed to access the server. The key is not needed when running directly on the server, as the connection is local.</p> <ol> <li>Test the connection</li> </ol> <p>Let us run the headscale command to verify that we can connect by listing our nodes:</p> <pre><code>headscale nodes list\n</code></pre> <p>You should now be able to see a list of your nodes from your workstation, and you can now control the <code>headscale</code> server from your workstation.</p>"},{"location":"remote-cli/#behind-a-proxy","title":"Behind a proxy","text":"<p>It is possible to run the gRPC remote endpoint behind a reverse proxy, like Nginx, and have it run on the same port as <code>headscale</code>.</p> <p>While this is not a supported feature, an example on how this can be set up on NixOS is shown here.</p>"},{"location":"remote-cli/#troubleshooting","title":"Troubleshooting","text":"<p>Checklist:</p> <ul> <li>Make sure you have the same <code>headscale</code> version on your server and workstation</li> <li>Make sure you use version <code>0.13.0</code> or newer.</li> <li>Verify that your TLS certificate is valid and trusted</li> <li>If you do not have access to a trusted certificate (e.g. from Let's Encrypt), add your self signed certificate to the trust store of your OS or</li> <li>Set <code>HEADSCALE_CLI_INSECURE</code> to 0 in your environement</li> </ul>"},{"location":"reverse-proxy/","title":"Running headscale behind a reverse proxy","text":"<p>Community documentation</p> <p>This page is not actively maintained by the headscale authors and is written by community members. It is not verified by <code>headscale</code> developers.</p> <p>It might be outdated and it might miss necessary steps.</p> <p>Running headscale behind a reverse proxy is useful when running multiple applications on the same server, and you want to reuse the same external IP and port - usually tcp/443 for HTTPS.</p>"},{"location":"reverse-proxy/#websockets","title":"WebSockets","text":"<p>The reverse proxy MUST be configured to support WebSockets, as it is needed for clients running Tailscale v1.30+.</p> <p>WebSockets support is required when using the headscale embedded DERP server. In this case, you will also need to expose the UDP port used for STUN (by default, udp/3478). Please check our config-example.yaml.</p>"},{"location":"reverse-proxy/#tls","title":"TLS","text":"<p>Headscale can be configured not to use TLS, leaving it to the reverse proxy to handle. Add the following configuration values to your headscale config file.</p> <pre><code>server_url: https://&lt;YOUR_SERVER_NAME&gt; # This should be the FQDN at which headscale will be served\nlisten_addr: 0.0.0.0:8080\nmetrics_listen_addr: 0.0.0.0:9090\ntls_cert_path: \"\"\ntls_key_path: \"\"\n</code></pre>"},{"location":"reverse-proxy/#nginx","title":"nginx","text":"<p>The following example configuration can be used in your nginx setup, substituting values as necessary. <code>&lt;IP:PORT&gt;</code> should be the IP address and port where headscale is running. In most cases, this will be <code>http://localhost:8080</code>.</p> <pre><code>map $http_upgrade $connection_upgrade {\ndefault      keep-alive;\n'websocket'  upgrade;\n''           close;\n}\nserver {\nlisten 80;\nlisten [::]:80;\nlisten 443      ssl http2;\nlisten [::]:443 ssl http2;\nserver_name &lt;YOUR_SERVER_NAME&gt;;\nssl_certificate &lt;PATH_TO_CERT&gt;;\nssl_certificate_key &lt;PATH_CERT_KEY&gt;;\nssl_protocols TLSv1.2 TLSv1.3;\nlocation / {\nproxy_pass http://&lt;IP:PORT&gt;;\nproxy_http_version 1.1;\nproxy_set_header Upgrade $http_upgrade;\nproxy_set_header Connection $connection_upgrade;\nproxy_set_header Host $server_name;\nproxy_redirect http:// https://;\nproxy_buffering off;\nproxy_set_header X-Real-IP $remote_addr;\nproxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\nproxy_set_header X-Forwarded-Proto $http_x_forwarded_proto;\nadd_header Strict-Transport-Security \"max-age=15552000; includeSubDomains\" always;\n}\n}\n</code></pre>"},{"location":"reverse-proxy/#istioenvoy","title":"istio/envoy","text":"<p>If you using Istio ingressgateway or Envoy as reverse proxy, there are some tips for you. If not set, you may see some debug log in proxy as below:</p> <pre><code>Sending local reply with details upgrade_failed\n</code></pre>"},{"location":"reverse-proxy/#envoy","title":"Envoy","text":"<p>You need add a new upgrade_type named <code>tailscale-control-protocol</code>. see detail</p>"},{"location":"reverse-proxy/#istio","title":"Istio","text":"<p>Same as envoy, we can use <code>EnvoyFilter</code> to add upgrade_type.</p> <pre><code>apiVersion: networking.istio.io/v1alpha3\nkind: EnvoyFilter\nmetadata:\nname: headscale-behind-istio-ingress\nnamespace: istio-system\nspec:\nconfigPatches:\n- applyTo: NETWORK_FILTER\nmatch:\nlistener:\nfilterChain:\nfilter:\nname: envoy.filters.network.http_connection_manager\npatch:\noperation: MERGE\nvalue:\ntyped_config:\n\"@type\": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager\nupgrade_configs:\n- upgrade_type: tailscale-control-protocol\n</code></pre>"},{"location":"reverse-proxy/#caddy","title":"Caddy","text":"<p>The following Caddyfile is all that is necessary to use Caddy as a reverse proxy for headscale, in combination with the <code>config.yaml</code> specifications above to disable headscale's built in TLS. Replace values as necessary - <code>&lt;YOUR_SERVER_NAME&gt;</code> should be the FQDN at which headscale will be served, and <code>&lt;IP:PORT&gt;</code> should be the IP address and port where headscale is running. In most cases, this will be <code>localhost:8080</code>.</p> <pre><code>&lt;YOUR_SERVER_NAME&gt; {\n    reverse_proxy &lt;IP:PORT&gt;\n}\n</code></pre> <p>Caddy v2 will automatically provision a certficate for your domain/subdomain, force HTTPS, and proxy websockets - no further configuration is necessary.</p> <p>For a slightly more complex configuration which utilizes Docker containers to manage Caddy, Headscale, and Headscale-UI, Guru Computing's guide is an excellent reference.</p>"},{"location":"reverse-proxy/#apache","title":"Apache","text":"<p>The following minimal Apache config will proxy traffic to the Headscale instance on <code>&lt;IP:PORT&gt;</code>. Note that <code>upgrade=any</code> is required as a parameter for <code>ProxyPass</code> so that WebSockets traffic whose <code>Upgrade</code> header value is not equal to <code>WebSocket</code> (i. e. Tailscale Control Protocol) is forwarded correctly. See the Apache docs for more information on this.</p> <pre><code>&lt;VirtualHost *:443&gt;\n    ServerName &lt;YOUR_SERVER_NAME&gt;\n\n    ProxyPreserveHost On\n    ProxyPass / http://&lt;IP:PORT&gt;/ upgrade=any\n\n    SSLEngine On\n    SSLCertificateFile &lt;PATH_TO_CERT&gt;\n    SSLCertificateKeyFile &lt;PATH_CERT_KEY&gt;\n&lt;/VirtualHost&gt;\n</code></pre>"},{"location":"running-headscale-container/","title":"Running headscale in a container","text":"<p>Community documentation</p> <p>This page is not actively maintained by the headscale authors and is written by community members. It is not verified by <code>headscale</code> developers.</p> <p>It might be outdated and it might miss necessary steps.</p>"},{"location":"running-headscale-container/#goal","title":"Goal","text":"<p>This documentation has the goal of showing a user how-to set up and run <code>headscale</code> in a container. Docker is used as the reference container implementation, but there is no reason that it should not work with alternatives like Podman. The Docker image can be found on Docker Hub here.</p>"},{"location":"running-headscale-container/#configure-and-run-headscale","title":"Configure and run <code>headscale</code>","text":"<ol> <li>Prepare a directory on the host Docker node in your directory of choice, used to hold <code>headscale</code> configuration and the SQLite database:</li> </ol> <pre><code>mkdir -p ./headscale/config\ncd ./headscale\n</code></pre> <ol> <li>Create an empty SQlite datebase in the headscale directory:</li> </ol> <pre><code>touch ./config/db.sqlite\n</code></pre> <ol> <li>(Strongly Recommended) Download a copy of the [example configuration]config-example.yaml from the headscale repository.</li> </ol> <p>Using wget:</p> <pre><code>wget -O ./config/config.yaml https://raw.githubusercontent.com/juanfont/headscale/main/config-example.yaml\n</code></pre> <p>Using curl:</p> <pre><code>curl https://raw.githubusercontent.com/juanfont/headscale/main/config-example.yaml -o ./config/config.yaml\n</code></pre> <p>(Advanced) If you would like to hand craft a config file instead of downloading the example config file, create a blank <code>headscale</code> configuration in the headscale directory to edit:</p> <pre><code>touch ./config/config.yaml\n</code></pre> <p>Modify the config file to your preferences before launching Docker container. Here are some settings that you likely want:</p> <pre><code># Change to your hostname or host IP\nserver_url: http://your-host-name:8080\n# Listen to 0.0.0.0 so it's accessible outside the container\nmetrics_listen_addr: 0.0.0.0:9090\n# The default /var/lib/headscale path is not writable in the container\nprivate_key_path: /etc/headscale/private.key\n# The default /var/lib/headscale path is not writable in the container\nnoise:\nprivate_key_path: /etc/headscale/noise_private.key\n# The default /var/lib/headscale path is not writable  in the container\ndb_type: sqlite3\ndb_path: /etc/headscale/db.sqlite\n</code></pre> <ol> <li>Start the headscale server while working in the host headscale directory:</li> </ol> <pre><code>docker run \\\n--name headscale \\\n--detach \\\n--volume $(pwd)/config:/etc/headscale/ \\\n--publish 127.0.0.1:8080:8080 \\\n--publish 127.0.0.1:9090:9090 \\\nheadscale/headscale:&lt;VERSION&gt; \\\nheadscale serve\n</code></pre> <p>Note: use <code>0.0.0.0:8080:8080</code> instead of <code>127.0.0.1:8080:8080</code> if you want to expose the container externally.</p> <p>This command will mount <code>config/</code> under <code>/etc/headscale</code>, forward port 8080 out of the container so the <code>headscale</code> instance becomes available and then detach so headscale runs in the background.</p> <ol> <li>Verify <code>headscale</code> is running:</li> </ol> <p>Follow the container logs:</p> <pre><code>docker logs --follow headscale\n</code></pre> <p>Verify running containers:</p> <pre><code>docker ps\n</code></pre> <p>Verify <code>headscale</code> is available:</p> <pre><code>curl http://127.0.0.1:9090/metrics\n</code></pre> <ol> <li>Create a user (tailnet):</li> </ol> <pre><code>docker exec headscale \\\nheadscale users create myfirstuser\n</code></pre>"},{"location":"running-headscale-container/#register-a-machine-normal-login","title":"Register a machine (normal login)","text":"<p>On a client machine, execute the <code>tailscale</code> login command:</p> <pre><code>tailscale up --login-server YOUR_HEADSCALE_URL\n</code></pre> <p>To register a machine when running <code>headscale</code> in a container, take the headscale command and pass it to the container:</p> <pre><code>docker exec headscale \\\nheadscale --user myfirstuser nodes register --key &lt;YOU_+MACHINE_KEY&gt;\n</code></pre>"},{"location":"running-headscale-container/#register-machine-using-a-pre-authenticated-key","title":"Register machine using a pre authenticated key","text":"<p>Generate a key using the command line:</p> <pre><code>docker exec headscale \\\nheadscale --user myfirstuser preauthkeys create --reusable --expiration 24h\n</code></pre> <p>This will return a pre-authenticated key that can be used to connect a node to <code>headscale</code> during the <code>tailscale</code> command:</p> <pre><code>tailscale up --login-server &lt;YOUR_HEADSCALE_URL&gt; --authkey &lt;YOUR_AUTH_KEY&gt;\n</code></pre>"},{"location":"running-headscale-container/#debugging-headscale-running-in-docker","title":"Debugging headscale running in Docker","text":"<p>The <code>headscale/headscale</code> Docker container is based on a \"distroless\" image that does not contain a shell or any other debug tools. If you need to debug your application running in the Docker container, you can use the <code>-debug</code> variant, for example <code>headscale/headscale:x.x.x-debug</code>.</p>"},{"location":"running-headscale-container/#running-the-debug-docker-container","title":"Running the debug Docker container","text":"<p>To run the debug Docker container, use the exact same commands as above, but replace <code>headscale/headscale:x.x.x</code> with <code>headscale/headscale:x.x.x-debug</code> (<code>x.x.x</code> is the version of headscale). The two containers are compatible with each other, so you can alternate between them.</p>"},{"location":"running-headscale-container/#executing-commands-in-the-debug-container","title":"Executing commands in the debug container","text":"<p>The default command in the debug container is to run <code>headscale</code>, which is located at <code>/bin/headscale</code> inside the container.</p> <p>Additionally, the debug container includes a minimalist Busybox shell.</p> <p>To launch a shell in the container, use:</p> <pre><code>docker run -it headscale/headscale:x.x.x-debug sh\n</code></pre> <p>You can also execute commands directly, such as <code>ls /bin</code> in this example:</p> <pre><code>docker run headscale/headscale:x.x.x-debug ls /bin\n</code></pre> <p>Using <code>docker exec</code> allows you to run commands in an existing container.</p>"},{"location":"running-headscale-linux-manual/","title":"Running headscale on Linux","text":""},{"location":"running-headscale-linux-manual/#note-outdated-and-advanced","title":"Note: Outdated and \"advanced\"","text":"<p>This documentation is considered the \"legacy\"/advanced/manual version of the documentation, you most likely do not want to use this documentation and rather look at the distro specific documentation (TODO LINK)[].</p>"},{"location":"running-headscale-linux-manual/#goal","title":"Goal","text":"<p>This documentation has the goal of showing a user how-to set up and run <code>headscale</code> on Linux. In additional to the \"get up and running section\", there is an optional SystemD section describing how to make <code>headscale</code> run properly in a server environment.</p>"},{"location":"running-headscale-linux-manual/#configure-and-run-headscale","title":"Configure and run <code>headscale</code>","text":"<ol> <li>Download the latest <code>headscale</code> binary from GitHub's release page:</li> </ol> <pre><code>wget --output-document=/usr/local/bin/headscale \\\nhttps://github.com/juanfont/headscale/releases/download/v&lt;HEADSCALE VERSION&gt;/headscale_&lt;HEADSCALE VERSION&gt;_linux_&lt;ARCH&gt;\n</code></pre> <ol> <li>Make <code>headscale</code> executable:</li> </ol> <pre><code>chmod +x /usr/local/bin/headscale\n</code></pre> <ol> <li>Prepare a directory to hold <code>headscale</code> configuration and the SQLite database:</li> </ol> <pre><code># Directory for configuration\nmkdir -p /etc/headscale\n\n# Directory for Database, and other variable data (like certificates)\nmkdir -p /var/lib/headscale\n# or if you create a headscale user:\nuseradd \\\n--create-home \\\n--home-dir /var/lib/headscale/ \\\n--system \\\n--user-group \\\n--shell /usr/bin/nologin \\\nheadscale\n</code></pre> <ol> <li>Create an empty SQLite database:</li> </ol> <pre><code>touch /var/lib/headscale/db.sqlite\n</code></pre> <ol> <li>Create a <code>headscale</code> configuration:</li> </ol> <pre><code>touch /etc/headscale/config.yaml\n</code></pre> <p>(Strongly Recommended) Download a copy of the [example configuration]config-example.yaml from the headscale repository.</p> <ol> <li>Start the headscale server:</li> </ol> <pre><code>headscale serve\n</code></pre> <p>This command will start <code>headscale</code> in the current terminal session.</p> <p>To continue the tutorial, open a new terminal and let it run in the background. Alternatively use terminal emulators like tmux or screen.</p> <p>To run <code>headscale</code> in the background, please follow the steps in the SystemD section before continuing.</p> <ol> <li>Verify <code>headscale</code> is running:</li> </ol> <p>Verify <code>headscale</code> is available:</p> <pre><code>curl http://127.0.0.1:9090/metrics\n</code></pre> <ol> <li>Create a user (tailnet):</li> </ol> <pre><code>headscale users create myfirstuser\n</code></pre>"},{"location":"running-headscale-linux-manual/#register-a-machine-normal-login","title":"Register a machine (normal login)","text":"<p>On a client machine, execute the <code>tailscale</code> login command:</p> <pre><code>tailscale up --login-server YOUR_HEADSCALE_URL\n</code></pre> <p>Register the machine:</p> <pre><code>headscale --user myfirstuser nodes register --key &lt;YOUR_MACHINE_KEY&gt;\n</code></pre>"},{"location":"running-headscale-linux-manual/#register-machine-using-a-pre-authenticated-key","title":"Register machine using a pre authenticated key","text":"<p>Generate a key using the command line:</p> <pre><code>headscale --user myfirstuser preauthkeys create --reusable --expiration 24h\n</code></pre> <p>This will return a pre-authenticated key that can be used to connect a node to <code>headscale</code> during the <code>tailscale</code> command:</p> <pre><code>tailscale up --login-server &lt;YOUR_HEADSCALE_URL&gt; --authkey &lt;YOUR_AUTH_KEY&gt;\n</code></pre>"},{"location":"running-headscale-linux-manual/#running-headscale-in-the-background-with-systemd","title":"Running <code>headscale</code> in the background with SystemD","text":"<p> Deprecated: This part is very outdated and you should use the [pre-packaged Headscale for this](./running-headscale-linux.md</p> <p>This section demonstrates how to run <code>headscale</code> as a service in the background with SystemD. This should work on most modern Linux distributions.</p> <ol> <li>Create a SystemD service configuration at <code>/etc/systemd/system/headscale.service</code> containing:</li> </ol> <pre><code>[Unit]\nDescription=headscale controller\nAfter=syslog.target\nAfter=network.target\n\n[Service]\nType=simple\nUser=headscale\nGroup=headscale\nExecStart=/usr/local/bin/headscale serve\nRestart=always\nRestartSec=5\n\n# Optional security enhancements\nNoNewPrivileges=yes\nPrivateTmp=yes\nProtectSystem=strict\nProtectHome=yes\nWorkingDirectory=/var/lib/headscale\nReadWritePaths=/var/lib/headscale /var/run/headscale\nAmbientCapabilities=CAP_NET_BIND_SERVICE\nRuntimeDirectory=headscale\n\n[Install]\nWantedBy=multi-user.target\n</code></pre> <p>Note that when running as the headscale user ensure that, either you add your current user to the headscale group:</p> <pre><code>usermod -a -G headscale current_user\n</code></pre> <p>or run all headscale commands as the headscale user:</p> <pre><code>su - headscale\n</code></pre> <ol> <li>In <code>/etc/headscale/config.yaml</code>, override the default <code>headscale</code> unix socket with path that is writable by the <code>headscale</code> user or group:</li> </ol> <pre><code>unix_socket: /var/run/headscale/headscale.sock\n</code></pre> <ol> <li>Reload SystemD to load the new configuration file:</li> </ol> <pre><code>systemctl daemon-reload\n</code></pre> <ol> <li>Enable and start the new <code>headscale</code> service:</li> </ol> <pre><code>systemctl enable --now headscale\n</code></pre> <ol> <li>Verify the headscale service:</li> </ol> <pre><code>systemctl status headscale\n</code></pre> <p>Verify <code>headscale</code> is available:</p> <pre><code>curl http://127.0.0.1:9090/metrics\n</code></pre> <p><code>headscale</code> will now run in the background and start at boot.</p>"},{"location":"running-headscale-linux/","title":"Running headscale on Linux","text":""},{"location":"running-headscale-linux/#requirements","title":"Requirements","text":"<ul> <li>Ubuntu 20.04 or newer, Debian 11 or newer.</li> </ul>"},{"location":"running-headscale-linux/#goal","title":"Goal","text":"<p>Get Headscale up and running.</p> <p>This includes running Headscale with SystemD.</p>"},{"location":"running-headscale-linux/#migrating-from-manual-install","title":"Migrating from manual install","text":"<p>If you are migrating from the old manual install, the best thing would be to remove the files installed by following the guide in reverse.</p> <p>You should not delete the database (<code>/var/headscale/db.sqlite</code>) and the configuration (<code>/etc/headscale/config.yaml</code>).</p>"},{"location":"running-headscale-linux/#installation","title":"Installation","text":"<ol> <li>Download the lastest Headscale package for your platform (<code>.deb</code> for Ubuntu and Debian) from Headscale's releases page:</li> </ol> <pre><code>wget --output-document=headscale.deb \\\nhttps://github.com/juanfont/headscale/releases/download/v&lt;HEADSCALE VERSION&gt;/headscale_&lt;HEADSCALE VERSION&gt;_linux_&lt;ARCH&gt;.deb\n</code></pre> <ol> <li>Install Headscale:</li> </ol> <pre><code>sudo dpkg --install headscale.deb\n</code></pre> <ol> <li>Enable Headscale service, this will start Headscale at boot:</li> </ol> <pre><code>sudo systemctl enable headscale\n</code></pre> <ol> <li>Configure Headscale by editing the configuration file:</li> </ol> <pre><code>nano /etc/headscale/config.yaml\n</code></pre> <ol> <li>Start Headscale:</li> </ol> <pre><code>sudo systemctl start headscale\n</code></pre> <ol> <li>Check that Headscale is running as intended:</li> </ol> <pre><code>systemctl status headscale\n</code></pre>"},{"location":"running-headscale-linux/#using-headscale","title":"Using Headscale","text":""},{"location":"running-headscale-linux/#create-a-user","title":"Create a user","text":"<pre><code>headscale users create myfirstuser\n</code></pre>"},{"location":"running-headscale-linux/#register-a-machine-normal-login","title":"Register a machine (normal login)","text":"<p>On a client machine, run the <code>tailscale</code> login command:</p> <pre><code>tailscale up --login-server &lt;YOUR_HEADSCALE_URL&gt;\n</code></pre> <p>Register the machine:</p> <pre><code>headscale --user myfirstuser nodes register --key &lt;YOUR_MACHINE_KEY&gt;\n</code></pre>"},{"location":"running-headscale-linux/#register-machine-using-a-pre-authenticated-key","title":"Register machine using a pre authenticated key","text":"<p>Generate a key using the command line:</p> <pre><code>headscale --user myfirstuser preauthkeys create --reusable --expiration 24h\n</code></pre> <p>This will return a pre-authenticated key that is used to connect a node to <code>headscale</code> during the <code>tailscale</code> command:</p> <pre><code>tailscale up --login-server &lt;YOUR_HEADSCALE_URL&gt; --authkey &lt;YOUR_AUTH_KEY&gt;\n</code></pre>"},{"location":"running-headscale-openbsd/","title":"Running headscale on OpenBSD","text":"<p>Community documentation</p> <p>This page is not actively maintained by the headscale authors and is written by community members. It is not verified by <code>headscale</code> developers.</p> <p>It might be outdated and it might miss necessary steps.</p>"},{"location":"running-headscale-openbsd/#goal","title":"Goal","text":"<p>This documentation has the goal of showing a user how-to install and run <code>headscale</code> on OpenBSD 7.1. In additional to the \"get up and running section\", there is an optional rc.d section describing how to make <code>headscale</code> run properly in a server environment.</p>"},{"location":"running-headscale-openbsd/#install-headscale","title":"Install <code>headscale</code>","text":"<ol> <li>Install from ports (Not Recommend)</li> </ol> <p>As of OpenBSD 7.2, there's a headscale in ports collection, however, it's severely outdated(v0.12.4).    You can install it via <code>pkg_add headscale</code>.</p> <ol> <li>Install from source on OpenBSD 7.2</li> </ol> <pre><code># Install prerequistes\npkg_add go\n\ngit clone https://github.com/juanfont/headscale.git\n\ncd headscale\n\n# optionally checkout a release\n# option a. you can find offical relase at https://github.com/juanfont/headscale/releases/latest\n# option b. get latest tag, this may be a beta release\nlatestTag=$(git describe --tags `git rev-list --tags --max-count=1`)\ngit checkout $latestTag\ngo build -ldflags=\"-s -w -X github.com/juanfont/headscale/cmd/headscale/cli.Version=$latestTag\" github.com/juanfont/headscale\n\n# make it executable\nchmod a+x headscale\n\n# copy it to /usr/local/sbin\ncp headscale /usr/local/sbin\n</code></pre> <ol> <li>Install from source via cross compile</li> </ol> <pre><code># Install prerequistes\n# 1. go v1.20+: headscale newer than 0.21 needs go 1.20+ to compile\n# 2. gmake: Makefile in the headscale repo is written in GNU make syntax\ngit clone https://github.com/juanfont/headscale.git\n\ncd headscale\n\n# optionally checkout a release\n# option a. you can find offical relase at https://github.com/juanfont/headscale/releases/latest\n# option b. get latest tag, this may be a beta release\nlatestTag=$(git describe --tags `git rev-list --tags --max-count=1`)\ngit checkout $latestTag\nmake build GOOS=openbsd\n\n# copy headscale to openbsd machine and put it in /usr/local/sbin\n</code></pre>"},{"location":"running-headscale-openbsd/#configure-and-run-headscale","title":"Configure and run <code>headscale</code>","text":"<ol> <li>Prepare a directory to hold <code>headscale</code> configuration and the SQLite database:</li> </ol> <pre><code># Directory for configuration\nmkdir -p /etc/headscale\n\n# Directory for Database, and other variable data (like certificates)\nmkdir -p /var/lib/headscale\n</code></pre> <ol> <li>Create an empty SQLite database:</li> </ol> <pre><code>touch /var/lib/headscale/db.sqlite\n</code></pre> <ol> <li>Create a <code>headscale</code> configuration:</li> </ol> <pre><code>touch /etc/headscale/config.yaml\n</code></pre> <p>(Strongly Recommended) Download a copy of the [example configuration]config-example.yaml from the headscale repository.</p> <ol> <li>Start the headscale server:</li> </ol> <pre><code>headscale serve\n</code></pre> <p>This command will start <code>headscale</code> in the current terminal session.</p> <p>To continue the tutorial, open a new terminal and let it run in the background. Alternatively use terminal emulators like tmux.</p> <p>To run <code>headscale</code> in the background, please follow the steps in the rc.d section before continuing.</p> <ol> <li>Verify <code>headscale</code> is running:</li> </ol> <p>Verify <code>headscale</code> is available:</p> <pre><code>curl http://127.0.0.1:9090/metrics\n</code></pre> <ol> <li>Create a user (tailnet):</li> </ol> <pre><code>headscale users create myfirstuser\n</code></pre>"},{"location":"running-headscale-openbsd/#register-a-machine-normal-login","title":"Register a machine (normal login)","text":"<p>On a client machine, execute the <code>tailscale</code> login command:</p> <pre><code>tailscale up --login-server YOUR_HEADSCALE_URL\n</code></pre> <p>Register the machine:</p> <pre><code>headscale --user myfirstuser nodes register --key &lt;YOU_+MACHINE_KEY&gt;\n</code></pre>"},{"location":"running-headscale-openbsd/#register-machine-using-a-pre-authenticated-key","title":"Register machine using a pre authenticated key","text":"<p>Generate a key using the command line:</p> <pre><code>headscale --user myfirstuser preauthkeys create --reusable --expiration 24h\n</code></pre> <p>This will return a pre-authenticated key that can be used to connect a node to <code>headscale</code> during the <code>tailscale</code> command:</p> <pre><code>tailscale up --login-server &lt;YOUR_HEADSCALE_URL&gt; --authkey &lt;YOUR_AUTH_KEY&gt;\n</code></pre>"},{"location":"running-headscale-openbsd/#running-headscale-in-the-background-with-rcd","title":"Running <code>headscale</code> in the background with rc.d","text":"<p>This section demonstrates how to run <code>headscale</code> as a service in the background with rc.d.</p> <ol> <li>Create a rc.d service at <code>/etc/rc.d/headscale</code> containing:</li> </ol> <pre><code>#!/bin/ksh\ndaemon=\"/usr/local/sbin/headscale\"\ndaemon_logger=\"daemon.info\"\ndaemon_user=\"root\"\ndaemon_flags=\"serve\"\ndaemon_timeout=60\n. /etc/rc.d/rc.subr\n\nrc_bg=YES\nrc_reload=NO\n\nrc_cmd $1\n</code></pre> <ol> <li><code>/etc/rc.d/headscale</code> needs execute permission:</li> </ol> <pre><code>chmod a+x /etc/rc.d/headscale\n</code></pre> <ol> <li>Start <code>headscale</code> service:</li> </ol> <pre><code>rcctl start headscale\n</code></pre> <ol> <li>Make <code>headscale</code> service start at boot:</li> </ol> <pre><code>rcctl enable headscale\n</code></pre> <ol> <li>Verify the headscale service:</li> </ol> <pre><code>rcctl check headscale\n</code></pre> <p>Verify <code>headscale</code> is available:</p> <pre><code>curl http://127.0.0.1:9090/metrics\n</code></pre> <p><code>headscale</code> will now run in the background and start at boot.</p>"},{"location":"tls/","title":"Running the service via TLS (optional)","text":""},{"location":"tls/#lets-encrypt-acme","title":"Let's Encrypt / ACME","text":"<p>To get a certificate automatically via Let's Encrypt, set <code>tls_letsencrypt_hostname</code> to the desired certificate hostname. This name must resolve to the IP address(es) headscale is reachable on (i.e., it must correspond to the <code>server_url</code> configuration parameter). The certificate and Let's Encrypt account credentials will be stored in the directory configured in <code>tls_letsencrypt_cache_dir</code>. If the path is relative, it will be interpreted as relative to the directory the configuration file was read from. The certificate will automatically be renewed as needed.</p> <pre><code>tls_letsencrypt_hostname: \"\"\ntls_letsencrypt_listen: \":http\"\ntls_letsencrypt_cache_dir: \".cache\"\ntls_letsencrypt_challenge_type: HTTP-01\n</code></pre>"},{"location":"tls/#challenge-type-http-01","title":"Challenge type HTTP-01","text":"<p>The default challenge type <code>HTTP-01</code> requires that headscale is reachable on port 80 for the Let's Encrypt automated validation, in addition to whatever port is configured in <code>listen_addr</code>. By default, headscale listens on port 80 on all local IPs for Let's Encrypt automated validation.</p> <p>If you need to change the ip and/or port used by headscale for the Let's Encrypt validation process, set <code>tls_letsencrypt_listen</code> to the appropriate value. This can be handy if you are running headscale as a non-root user (or can't run <code>setcap</code>). Keep in mind, however, that Let's Encrypt will only connect to port 80 for the validation callback, so if you change <code>tls_letsencrypt_listen</code> you will also need to configure something else (e.g. a firewall rule) to forward the traffic from port 80 to the ip:port combination specified in <code>tls_letsencrypt_listen</code>.</p>"},{"location":"tls/#challenge-type-tls-alpn-01","title":"Challenge type TLS-ALPN-01","text":"<p>Alternatively, <code>tls_letsencrypt_challenge_type</code> can be set to <code>TLS-ALPN-01</code>. In this configuration, headscale listens on the ip:port combination defined in <code>listen_addr</code>. Let's Encrypt will only connect to port 443 for the validation callback, so if <code>listen_addr</code> is not set to port 443, something else (e.g. a firewall rule) will be required to forward the traffic from port 443 to the ip:port combination specified in <code>listen_addr</code>.</p>"},{"location":"tls/#bring-your-own-certificate","title":"Bring your own certificate","text":"<p>headscale can also be configured to expose its web service via TLS. To configure the certificate and key file manually, set the <code>tls_cert_path</code> and <code>tls_cert_path</code> configuration parameters. If the path is relative, it will be interpreted as relative to the directory the configuration file was read from.</p> <pre><code>tls_cert_path: \"\"\ntls_key_path: \"\"\n</code></pre>"},{"location":"web-ui/","title":"Headscale web interface","text":"<p>Community contributions</p> <p>This page contains community contributions. The projects listed here are not maintained by the Headscale authors and are written by community members.</p> Name Repository Link Description Status headscale-webui Github A simple Headscale web UI for small-scale deployments. Alpha headscale-ui Github A web frontend for the headscale Tailscale-compatible coordination server Alpha HeadscaleUi GitHub A static headscale admin ui, no backend enviroment required Alpha <p>You can ask for support on our dedicated Discord channel.</p>"},{"location":"windows-client/","title":"Connecting a Windows client","text":""},{"location":"windows-client/#goal","title":"Goal","text":"<p>This documentation has the goal of showing how a user can use the official Windows Tailscale client with <code>headscale</code>.</p>"},{"location":"windows-client/#add-registry-keys","title":"Add registry keys","text":"<p>To make the Windows client behave as expected and to run well with <code>headscale</code>, two registry keys must be set:</p> <ul> <li><code>HKLM:\\SOFTWARE\\Tailscale IPN\\UnattendedMode</code> must be set to <code>always</code> as a <code>string</code> type, to allow Tailscale to run properly in the background</li> <li><code>HKLM:\\SOFTWARE\\Tailscale IPN\\LoginURL</code> must be set to <code>&lt;YOUR HEADSCALE URL&gt;</code> as a <code>string</code> type, to ensure Tailscale contacts the correct control server.</li> </ul> <p>You can set these using the Windows Registry Editor:</p> <p></p> <p>Or via the following Powershell commands (right click Powershell icon and select \"Run as administrator\"):</p> <pre><code>New-ItemProperty -Path 'HKLM:\\Software\\Tailscale IPN' -Name UnattendedMode -PropertyType String -Value always\nNew-ItemProperty -Path 'HKLM:\\Software\\Tailscale IPN' -Name LoginURL -PropertyType String -Value https://YOUR-HEADSCALE-URL\n</code></pre> <p>The Tailscale Windows client has been observed to reset its configuration on logout/reboot and these two keys resolves that issue.</p> <p>For a guide on how to edit registry keys, check out Computer Hope.</p>"},{"location":"windows-client/#installation","title":"Installation","text":"<p>Download the Official Windows Client and install it.</p> <p>When the installation has finished, start Tailscale and log in (you might have to click the icon in the system tray).</p> <p>The log in should open a browser Window and direct you to your <code>headscale</code> instance.</p>"},{"location":"windows-client/#troubleshooting","title":"Troubleshooting","text":"<p>If you are seeing repeated messages like:</p> <pre><code>[GIN] 2022/02/10 - 16:39:34 | 200 |    1.105306ms |       127.0.0.1 | POST     \"/machine/redacted\"\n</code></pre> <p>in your <code>headscale</code> output, turn on <code>DEBUG</code> logging and look for:</p> <pre><code>2022-02-11T00:59:29Z DBG Machine registration has expired. Sending a authurl to register machine=redacted\n</code></pre> <p>This typically means that the registry keys above was not set appropriately.</p> <p>To reset and try again, it is important to do the following:</p> <ol> <li>Ensure the registry keys from the previous guide is correctly set.</li> <li>Shut down the Tailscale service (or the client running in the tray)</li> <li>Delete Tailscale Application data folder, located at <code>C:\\Users\\&lt;USERNAME&gt;\\AppData\\Local\\Tailscale</code> and try to connect again.</li> <li>Ensure the Windows node is deleted from headscale (to ensure fresh setup)</li> <li>Start Tailscale on the windows machine and retry the login.</li> </ol>"},{"location":"packaging/","title":"Packaging","text":"<p>We use nFPM for making <code>.deb</code>, <code>.rpm</code> and <code>.apk</code>.</p> <p>This folder contains files we need to package with these releases.</p>"},{"location":"proposals/001-acls/","title":"ACLs","text":"<p>A key component of tailscale is the notion of Tailnet. This notion is hidden but the implications that it have on how to use tailscale are not.</p> <p>For tailscale an tailnet is the following:</p> <p>For personal users, you are a tailnet of many devices and one person. Each device gets a private Tailscale IP address in the CGNAT range and every device can talk directly to every other device, wherever they are on the internet.</p> <p>For businesses and organizations, a tailnet is many devices and many users. It can be based on your Microsoft Active Directory, your Google Workspace, a GitHub organization, Okta tenancy, or other identity provider namespace. All of the devices and users in your tailnet can be seen by the tailnet administrators in the Tailscale admin console. There you can apply tailnet-wide configuration, such as ACLs that affect visibility of devices inside your tailnet, DNS settings, and more.</p>"},{"location":"proposals/001-acls/#current-implementation-and-issues","title":"Current implementation and issues","text":"<p>Currently in headscale, the namespaces are used both as tailnet and users. The issue is that if we want to use the ACL's we can't use both at the same time.</p> <p>Tailnet's cannot communicate with each others. So we can't have an ACL that authorize tailnet (namespace) A to talk to tailnet (namespace) B.</p> <p>We also can't write ACLs based on the users (namespaces in headscale) since all devices belong to the same user.</p> <p>With the current implementation the only ACL that we can user is to associate each headscale IP to a host manually then write the ACLs according to this manual mapping.</p> <pre><code>{\n\"hosts\": {\n\"host1\": \"100.64.0.1\",\n\"server\": \"100.64.0.2\"\n},\n\"acls\": [\n{ \"action\": \"accept\", \"users\": [\"host1\"], \"ports\": [\"host2:80,443\"] }\n]\n}\n</code></pre> <p>While this works, it requires a lot of manual editing on the configuration and to keep track of all devices IP address.</p>"},{"location":"proposals/001-acls/#proposition-for-a-next-implementation","title":"Proposition for a next implementation","text":"<p>In order to ease the use of ACL's we need to split the tailnet and users notion.</p> <p>A solution could be to consider a headscale server (in it's entirety) as a tailnet.</p> <p>For personal users the default behavior could either allow all communications between all namespaces (like tailscale) or dissallow all communications between namespaces (current behavior).</p> <p>For businesses and organisations, viewing a headscale instance a single tailnet would allow users (namespace) to talk to each other with the ACLs. As described in tailscale's documentation [[1]], a server should be tagged and personnal devices should be tied to a user. Translated in headscale's terms each user can have multiple devices and all those devices should be in the same namespace. The servers should be tagged and used as such.</p> <p>This implementation would render useless the sharing feature that is currently implemented since an ACL could do the same. Simplifying to only one user interface to do one thing is easier and less confusing for the users.</p> <p>To better suit the ACLs in this proposition, it's advised to consider that each namespaces belong to one person. This person can have multiple devices, they will all be considered as the same user in the ACLs. OIDC feature wouldn't need to map people to namespace, just create a namespace if the person isn't registered yet.</p> <p>As a sidenote, users would like to write ACLs as YAML. We should offer users the ability to rules in either format (HuJSON or YAML).</p>"},{"location":"proposals/001-acls/#example","title":"Example","text":"<p>Let's build an example use case for a small business (It may be the place where ACL's are the most useful).</p> <p>We have a small company with a boss, an admin, two developper and an intern.</p> <p>The boss should have access to all servers but not to the users hosts. Admin should also have access to all hosts except that their permissions should be limited to maintaining the hosts (for example purposes). The developers can do anything they want on dev hosts, but only watch on productions hosts. Intern can only interact with the development servers.</p> <p>Each user have at least a device connected to the network and we have some servers.</p> <ul> <li>database.prod</li> <li>database.dev</li> <li>app-server1.prod</li> <li>app-server1.dev</li> <li>billing.internal</li> </ul>"},{"location":"proposals/001-acls/#current-headscale-implementation","title":"Current headscale implementation","text":"<p>Let's create some namespaces</p> <pre><code>headscale namespaces create prod\nheadscale namespaces create dev\nheadscale namespaces create internal\nheadscale namespaces create users\n\nheadscale nodes register -n users boss-computer\nheadscale nodes register -n users admin1-computer\nheadscale nodes register -n users dev1-computer\nheadscale nodes register -n users dev1-phone\nheadscale nodes register -n users dev2-computer\nheadscale nodes register -n users intern1-computer\n\nheadscale nodes register -n prod database\nheadscale nodes register -n prod app-server1\n\nheadscale nodes register -n dev database\nheadscale nodes register -n dev app-server1\n\nheadscale nodes register -n internal billing\n\nheadscale nodes list\nID  | Name              | Namespace | IP address\n1   | boss-computer     | users     | 100.64.0.1\n2   | admin1-computer   | users     | 100.64.0.2\n3   | dev1-computer     | users     | 100.64.0.3\n4   | dev1-phone        | users     | 100.64.0.4\n5   | dev2-computer     | users     | 100.64.0.5\n6   | intern1-computer  | users     | 100.64.0.6\n7   | database          | prod      | 100.64.0.7\n8   | app-server1       | prod      | 100.64.0.8\n9   | database          | dev       | 100.64.0.9\n10  | app-server1       | dev       | 100.64.0.10\n11  | internal          | internal  | 100.64.0.11\n</code></pre> <p>In order to only allow the communications related to our description above we need to add the following ACLs</p> <pre><code>{\n\"hosts\": {\n\"boss-computer\": \"100.64.0.1\",\n\"admin1-computer\": \"100.64.0.2\",\n\"dev1-computer\": \"100.64.0.3\",\n\"dev1-phone\": \"100.64.0.4\",\n\"dev2-computer\": \"100.64.0.5\",\n\"intern1-computer\": \"100.64.0.6\",\n\"prod-app-server1\": \"100.64.0.8\"\n},\n\"groups\": {\n\"group:dev\": [\"dev1-computer\", \"dev1-phone\", \"dev2-computer\"],\n\"group:admin\": [\"admin1-computer\"],\n\"group:boss\": [\"boss-computer\"],\n\"group:intern\": [\"intern1-computer\"]\n},\n\"acls\": [\n// boss have access to all servers but no users hosts\n{\n\"action\": \"accept\",\n\"users\": [\"group:boss\"],\n\"ports\": [\"prod:*\", \"dev:*\", \"internal:*\"]\n},\n// admin have access to adminstration port (lets only consider port 22 here)\n{\n\"action\": \"accept\",\n\"users\": [\"group:admin\"],\n\"ports\": [\"prod:22\", \"dev:22\", \"internal:22\"]\n},\n// dev can do anything on dev servers and check access on prod servers\n{\n\"action\": \"accept\",\n\"users\": [\"group:dev\"],\n\"ports\": [\"dev:*\", \"prod-app-server1:80,443\"]\n},\n// interns only have access to port 80 and 443 on dev servers (lame internship)\n{ \"action\": \"accept\", \"users\": [\"group:intern\"], \"ports\": [\"dev:80,443\"] },\n// users can access their own devices\n{\n\"action\": \"accept\",\n\"users\": [\"dev1-computer\"],\n\"ports\": [\"dev1-phone:*\"]\n},\n{\n\"action\": \"accept\",\n\"users\": [\"dev1-phone\"],\n\"ports\": [\"dev1-computer:*\"]\n},\n// internal namespace communications should still be allowed within the namespace\n{ \"action\": \"accept\", \"users\": [\"dev\"], \"ports\": [\"dev:*\"] },\n{ \"action\": \"accept\", \"users\": [\"prod\"], \"ports\": [\"prod:*\"] },\n{ \"action\": \"accept\", \"users\": [\"internal\"], \"ports\": [\"internal:*\"] }\n]\n}\n</code></pre> <p>Since communications between namespace isn't possible we also have to share the devices between the namespaces.</p> <pre><code>// add boss host to prod, dev and internal network\nheadscale nodes share -i 1 -n prod\nheadscale nodes share -i 1 -n dev\nheadscale nodes share -i 1 -n internal\n\n// add admin computer to prod, dev and internal network\nheadscale nodes share -i 2 -n prod\nheadscale nodes share -i 2 -n dev\nheadscale nodes share -i 2 -n internal\n\n// add all dev to prod and dev network\nheadscale nodes share -i 3 -n dev\nheadscale nodes share -i 4 -n dev\nheadscale nodes share -i 3 -n prod\nheadscale nodes share -i 4 -n prod\nheadscale nodes share -i 5 -n dev\nheadscale nodes share -i 5 -n prod\n\nheadscale nodes share -i 6 -n dev\n</code></pre> <p>This fake network have not been tested but it should work. Operating it could be quite tedious if the company grows. Each time a new user join we have to add it to a group, and share it to the correct namespaces. If the user want multiple devices we have to allow communication to each of them one by one. If business conduct a change in the organisations we may have to rewrite all acls and reorganise all namespaces.</p> <p>If we add servers in production we should also update the ACLs to allow dev access to certain category of them (only app servers for example).</p>"},{"location":"proposals/001-acls/#example-based-on-the-proposition-in-this-document","title":"example based on the proposition in this document","text":"<p>Let's create the namespaces</p> <pre><code>headscale namespaces create boss\nheadscale namespaces create admin1\nheadscale namespaces create dev1\nheadscale namespaces create dev2\nheadscale namespaces create intern1\n</code></pre> <p>We don't need to create namespaces for the servers because the servers will be tagged. When registering the servers we will need to add the flag <code>--advertised-tags=tag:&lt;tag1&gt;,tag:&lt;tag2&gt;</code>, and the user (namespace) that is registering the server should be allowed to do it. Since anyone can add tags to a server they can register, the check of the tags is done on headscale server and only valid tags are applied. A tag is valid if the namespace that is registering it is allowed to do it.</p> <p>Here are the ACL's to implement the same permissions as above:</p> <pre><code>{\n// groups are simpler and only list the namespaces name\n\"groups\": {\n\"group:boss\": [\"boss\"],\n\"group:dev\": [\"dev1\", \"dev2\"],\n\"group:admin\": [\"admin1\"],\n\"group:intern\": [\"intern1\"]\n},\n\"tagOwners\": {\n// the administrators can add servers in production\n\"tag:prod-databases\": [\"group:admin\"],\n\"tag:prod-app-servers\": [\"group:admin\"],\n// the boss can tag any server as internal\n\"tag:internal\": [\"group:boss\"],\n// dev can add servers for dev purposes as well as admins\n\"tag:dev-databases\": [\"group:admin\", \"group:dev\"],\n\"tag:dev-app-servers\": [\"group:admin\", \"group:dev\"]\n// interns cannot add servers\n},\n\"acls\": [\n// boss have access to all servers\n{\n\"action\": \"accept\",\n\"users\": [\"group:boss\"],\n\"ports\": [\n\"tag:prod-databases:*\",\n\"tag:prod-app-servers:*\",\n\"tag:internal:*\",\n\"tag:dev-databases:*\",\n\"tag:dev-app-servers:*\"\n]\n},\n// admin have only access to administrative ports of the servers\n{\n\"action\": \"accept\",\n\"users\": [\"group:admin\"],\n\"ports\": [\n\"tag:prod-databases:22\",\n\"tag:prod-app-servers:22\",\n\"tag:internal:22\",\n\"tag:dev-databases:22\",\n\"tag:dev-app-servers:22\"\n]\n},\n{\n\"action\": \"accept\",\n\"users\": [\"group:dev\"],\n\"ports\": [\n\"tag:dev-databases:*\",\n\"tag:dev-app-servers:*\",\n\"tag:prod-app-servers:80,443\"\n]\n},\n// servers should be able to talk to database. Database should not be able to initiate connections to server\n{\n\"action\": \"accept\",\n\"users\": [\"tag:dev-app-servers\"],\n\"ports\": [\"tag:dev-databases:5432\"]\n},\n{\n\"action\": \"accept\",\n\"users\": [\"tag:prod-app-servers\"],\n\"ports\": [\"tag:prod-databases:5432\"]\n},\n// interns have access to dev-app-servers only in reading mode\n{\n\"action\": \"accept\",\n\"users\": [\"group:intern\"],\n\"ports\": [\"tag:dev-app-servers:80,443\"]\n},\n// we still have to allow internal namespaces communications since nothing guarantees that each user have their own namespaces. This could be talked over.\n{ \"action\": \"accept\", \"users\": [\"boss\"], \"ports\": [\"boss:*\"] },\n{ \"action\": \"accept\", \"users\": [\"dev1\"], \"ports\": [\"dev1:*\"] },\n{ \"action\": \"accept\", \"users\": [\"dev2\"], \"ports\": [\"dev2:*\"] },\n{ \"action\": \"accept\", \"users\": [\"admin1\"], \"ports\": [\"admin1:*\"] },\n{ \"action\": \"accept\", \"users\": [\"intern1\"], \"ports\": [\"intern1:*\"] }\n]\n}\n</code></pre> <p>With this implementation, the sharing step is not necessary. Maintenance cost of the ACL file is lower and less tedious (no need to map hostname and IP's into it).</p>"},{"location":"proposals/002-better-routing/","title":"Better route management","text":"<p>As of today, route management in Headscale is very basic and does not allow for much flexibility, including implementing subnet HA, 4via6 or more advanced features. We also have a number of bugs (e.g., routes exposed by ephemeral nodes)</p> <p>This proposal aims to improve the route management.</p>"},{"location":"proposals/002-better-routing/#current-situation","title":"Current situation","text":"<p>Routes advertised by the nodes are read from the Hostinfo struct. If approved from the the CLI or via autoApprovers, the route is added to the EnabledRoutes field in <code>Machine</code>.</p> <p>This means that the advertised routes are not persisted in the database, as Hostinfo is always replaced. In the same way, EnabledRoutes can get out of sync with the actual routes in the node.</p> <p>In case of colliding routes (i.e., subnets that are exposed from multiple nodes), we are currently just sending all of them in <code>PrimaryRoutes</code>... and hope for the best. (<code>PrimaryRoutes</code> is the field in <code>Node</code> used for subnet failover).</p>"},{"location":"proposals/002-better-routing/#proposal","title":"Proposal","text":"<p>The core part is to create a new <code>Route</code> struct (and DB table), with the following fields:</p> <pre><code>type Route struct {\nID          uint64 `gorm:\"primary_key\"`\nMachine     *Machine\nPrefix      IPPrefix\nAdvertised  bool\nEnabled     bool\nIsPrimary   bool\nCreatedAt   *time.Time\nUpdatedAt   *time.Time\nDeletedAt   *time.Time\n}\n</code></pre> <ul> <li> <p>The <code>Advertised</code> field is set to true if the route is being advertised by the node. It is set to false if the route is removed. This way we can indicate if a later enabled route has stopped being advertised. A similar behaviour happens in the Tailscale.com control panel.</p> </li> <li> <p>The <code>Enabled</code> field is set to true if the route is enabled - via CLI or autoApprovers.</p> </li> <li> <p><code>IsPrimary</code> indicates if Headscale has selected this route as the primary route for that particular subnet. This allows us to implement subnet failover. This would be fully automatic if there is more than subnet routers advertising the same network - which is the behaviour of Tailscale.com.</p> </li> </ul>"},{"location":"proposals/002-better-routing/#stuff-to-bear-in-mind","title":"Stuff to bear in mind","text":"<ul> <li>We need to make sure to migrate the current <code>EnabledRoutes</code> of <code>Machine</code> into the new table.</li> <li>When a node stops sharing a subnet, I reckon we should mark it both as not <code>Advertised</code> and not <code>Enabled</code>. Users should re-enable it if the node advertises it again.</li> <li>If only one subnet router is advertising a subnet, we should mark it as primary.</li> <li>Regarding subnet failover, the current behaviour of Tailscale.com is to perform the failover after 15 seconds from the node disconnecting from their control panel. I reckon we cannot do the same currently. Our maximum granularity is the keep alive period.</li> </ul>"}]}